# Chapter 10—结构体和方法
Go 以别名类型或结构体的形式支持用户定义或自定义类型。结构体是复合类型，用于定义由许多属性组成的类型，每个属性都有自己的类型和值，将数据组合在一起。然后可以像访问单个实体一样访问这些数据。 它们也是值类型，所以用 `new` 构建。构成结构体类型的组件数据片段称为字段(fields), 一个字段有一个类型和一个名字; 结构体中的字段名称必须是唯一的。

## 10.1.结构体的定义
通常定义结构体的一般形式如下：
```go
type identifier struct {
    field1 type1
    field2 type2
    …
}
```
如果结构体中的某个字段从不被使用，可以被命名为 `_`。

**使用 new**

使用 `new` 来申请一个结构体变量的内存，返回指向被申请存储空间的指针。
```go
var t *T = new(T)

// 或者不在同一行
var t *T
t = new(T)

// 习惯写法
t := new(T)
```
此时结构体内的字段的值为对应类型的零值。

一个简单的例子:
```go
package main

import "fmt"

type struct1 struct {
	i1  int
	f1  float32
	str string
}

func main() {
	ms := new(struct1)
	// var ms struct1
	ms.i1 = 10
	ms.f1 = 15.5
	ms.str = "Chris"
	fmt.Printf("The int is: %d\n", ms.i1)
	fmt.Printf("The float is: %f\n", ms.f1)
	fmt.Printf("The string is: %s\n", ms.str)
	fmt.Println(ms)
}
// The int is: 10
// The float is: 15.500000
// The string is: Chris
// &{10 15.5 Chris}
```
通过 `structname.fieldname = value` 来对结构体内的字段进行访问。结构体变量和指针的访问方式相同
```go
type myStruct struct { i int }
var v myStruct
var p *myStruct
v.i
p.i
```
**结构体文字**
```go
ms := &struct1{10, 15.5, "Chris"}

var mt struct1
mt = struct1{10, 15.5, "Chris"}
```
`new(Type)` 和 `&Type{}` 是等价的表达式

三种初始化的方式：
```go
type Interval struct {
    start int
    end int
}

inter := Interval{0,3}
inter2 := Interval{end:5, start:1}
inter3 := Interval{end:5}
```
> 结构体中的字段遵循 `首字母大写则对外可见` 的原则。

下面展示 结构体在内存中布局：
![结构体在内存中布局](https://raw.githubusercontent.com/shijie93/the_way_to_go/master/chapter-10/struct_in_memory.png)

结构体嵌套的内存布局：
```go
type Rect1 struct { Min, Max Point }
type Rect2 struct { Min, Max *Point }
```
![结构体嵌套的内存布局](https://raw.githubusercontent.com/shijie93/the_way_to_go/master/chapter-10/struct_in_struct.png)

## 10.2.用 Factory 方法创建一个结构体变量

### 10.2.1.结构体工厂
Go不像OO语言那样支持构造函数，但类似于构造函数的工厂函数很容易实现。
```go
type File struct {
	fd int // file descriptor number
	name string // file name
}

func NewFile(fd int, name string) *File {
	if fd < 0 {
	return nil
	}
	return &File{fd, name}
}

f := NewFile(10, "./test.txt")
```
> 结构体，使用 new(File) 和 &File{} 等价

如果你有一个struct T类型，并且你很快想知道一个实例在内存中占用了多少字节，可以使用 : `size := unsafe.Sizeof(T{})`

**强制使用工厂方法**

利用可见性的规则，在包内使结构体本身对外不可见，使用方法来对其进行构造：
```go
package matrix
type matrix struct {
     name string
}

function NewMatrix(params) *matrix {
	m := new(matrix)
	// m is initialized
	return m
}
```
此时无法直接构造结构体实例，从而只能通过 `包名.方法` 的方式。

### 10.2.2 重新来看 new 和 make
看下面这个例子：
```go
package main

type Foo map[string]string
type Bar struct {
	thingOne string
	thingTwo int
}

func main() {
	// OK:
	y := new(Bar)
	(*y).thingOne = "hello"
	(*y).thingTwo = 1
	// not OK:
	z := make(Bar) // compile error: cannot make type Bar
	z.thingOne = "hello"
	z.thingTwo = 1
	// OK:
	x := make(Foo)
	x["x"] = "goodbye"
	x["y"] = "world"
	// not OK:
	u := new(Foo)
	(*u)["x"] = "goodbye" // !! panic !!: runtime error: assignment to entry in nil map
	(*u)["y"] = "world"
}
```
结构体使用 make 不会那么糟糕，因为编译器会帮助你检出错误，但是 map 使用 new 时，编译器不会这么做，而是会产生一个运行时错误，所以一定要注意这一点！！

## 10.3.使用结构体的定制化包
structPack.go:
```go
package structPack
type ExpStruct struct {
	Mi1 int
	Mf1 float
}
```
main.go:
```go
package main
import (
	"fmt"
	"./struct_pack/structPack"
)
func main() {
	struct1 := new(structPack.ExpStruct)
	struct1.Mi1 = 10
	struct1.Mf1 = 16.
	fmt.Printf("Mi1 = %d\n", struct1.Mi1)
	fmt.Printf("Mf1 = %f\n", struct1.Mf1)
}
```

## 10.4.带标签的结构体
结构中的字段除了名称和类型之外，还可以有一个标签：这是附加到字段的字符串，可以是文档或其他重要标签。 标签内容不能在正常编程中使用，只有包 `reflect` 可以访问它。 
```go
package main

import (
	"fmt"
	"reflect"
)

type TagType struct { // tags
	field1 bool   "An important answer"
	field2 string "The name of the thing"
	field3 int    "How much there are"
}

func main() {
	tt := TagType{true, "Barak Obama", 1}
	for i := 0; i < 3; i++ {
		refTag(tt, i)
	}
}
func refTag(tt TagType, ix int) {
	ttType := reflect.TypeOf(tt)
	ixField := ttType.Field(ix)
	fmt.Printf("%v\n", ixField.Tag)
}
// An important answer
// The name of the thing
// How much there are
```

## 10.5.匿名字段和嵌入式结构体