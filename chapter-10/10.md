# Chapter 10—结构体和方法
Go 以别名类型或结构体的形式支持用户定义或自定义类型。结构体是复合类型，用于定义由许多属性组成的类型，每个属性都有自己的类型和值，将数据组合在一起。然后可以像访问单个实体一样访问这些数据。 它们也是值类型，所以用 `new` 构建。构成结构体类型的组件数据片段称为字段(fields), 一个字段有一个类型和一个名字; 结构体中的字段名称必须是唯一的。

## 10.1.结构体的定义
通常定义结构体的一般形式如下：
```go
type identifier struct {
    field1 type1
    field2 type2
    …
}
```
如果结构体中的某个字段从不被使用，可以被命名为 `_`。

**使用 new**

使用 `new` 来申请一个结构体变量的内存，返回指向被申请存储空间的指针。
```go
var t *T = new(T)

// 或者不在同一行
var t *T
t = new(T)

// 习惯写法
t := new(T)
```
此时结构体内的字段的值为对应类型的零值。

一个简单的例子:
```go
package main

import "fmt"

type struct1 struct {
	i1  int
	f1  float32
	str string
}

func main() {
	ms := new(struct1)
	// var ms struct1
	ms.i1 = 10
	ms.f1 = 15.5
	ms.str = "Chris"
	fmt.Printf("The int is: %d\n", ms.i1)
	fmt.Printf("The float is: %f\n", ms.f1)
	fmt.Printf("The string is: %s\n", ms.str)
	fmt.Println(ms)
}
// The int is: 10
// The float is: 15.500000
// The string is: Chris
// &{10 15.5 Chris}
```
通过 `structname.fieldname = value` 来对结构体内的字段进行访问。结构体变量和指针的访问方式相同
```go
type myStruct struct { i int }
var v myStruct
var p *myStruct
v.i
p.i
```
**结构体文字**
```go
ms := &struct1{10, 15.5, "Chris"}

var mt struct1
mt = struct1{10, 15.5, "Chris"}
```
`new(Type)` 和 `&Type{}` 是等价的表达式

三种初始化的方式：
```go
type Interval struct {
    start int
    end int
}

inter := Interval{0,3}
inter2 := Interval{end:5, start:1}
inter3 := Interval{end:5}
```
> 结构体中的字段遵循 `首字母大写则对外可见` 的原则。

下面展示 结构体在内存中布局：
![结构体在内存中布局](https://raw.githubusercontent.com/shijie93/the_way_to_go/master/chapter-10/struct_in_memory.png)

结构体嵌套的内存布局：
```go
type Rect1 struct { Min, Max Point }
type Rect2 struct { Min, Max *Point }
```
![结构体嵌套的内存布局](https://raw.githubusercontent.com/shijie93/the_way_to_go/master/chapter-10/struct_in_struct.png)

## 10.2.用 Factory 方法创建一个结构体变量

### 10.2.1.结构体工厂
Go不像OO语言那样支持构造函数，但类似于构造函数的工厂函数很容易实现。
```go
type File struct {
	fd int // file descriptor number
	name string // file name
}

func NewFile(fd int, name string) *File {
	if fd < 0 {
	return nil
	}
	return &File{fd, name}
}

f := NewFile(10, "./test.txt")
```
> 结构体，使用 new(File) 和 &File{} 等价

如果你有一个struct T类型，并且你很快想知道一个实例在内存中占用了多少字节，可以使用 : `size := unsafe.Sizeof(T{})`

**强制使用工厂方法**

利用可见性的规则，在包内使结构体本身对外不可见，使用方法来对其进行构造：
```go
package matrix
type matrix struct {
     name string
}

function NewMatrix(params) *matrix {
	m := new(matrix)
	// m is initialized
	return m
}
```
此时无法直接构造结构体实例，从而只能通过 `包名.方法` 的方式。

### 10.2.2 重新来看 new 和 make
看下面这个例子：
```go
package main

type Foo map[string]string
type Bar struct {
	thingOne string
	thingTwo int
}

func main() {
	// OK:
	y := new(Bar)
	(*y).thingOne = "hello"
	(*y).thingTwo = 1
	// not OK:
	z := make(Bar) // compile error: cannot make type Bar
	z.thingOne = "hello"
	z.thingTwo = 1
	// OK:
	x := make(Foo)
	x["x"] = "goodbye"
	x["y"] = "world"
	// not OK:
	u := new(Foo)
	(*u)["x"] = "goodbye" // !! panic !!: runtime error: assignment to entry in nil map
	(*u)["y"] = "world"
}
```
结构体使用 make 不会那么糟糕，因为编译器会帮助你检出错误，但是 map 使用 new 时，编译器不会这么做，而是会产生一个**运行时错误**，所以一定要注意这一点！！

## 10.3.使用结构体的定制化包
structPack.go:
```go
package structPack
type ExpStruct struct {
	Mi1 int
	Mf1 float
}
```
main.go:
```go
package main
import (
	"fmt"
	"./struct_pack/structPack"
)
func main() {
	struct1 := new(structPack.ExpStruct)
	struct1.Mi1 = 10
	struct1.Mf1 = 16.
	fmt.Printf("Mi1 = %d\n", struct1.Mi1)
	fmt.Printf("Mf1 = %f\n", struct1.Mf1)
}
```

## 10.4.带标签的结构体
结构中的字段除了名称和类型之外，还可以有一个标签：这是附加到字段的字符串，可以是文档或其他重要标签。 标签内容不能在正常编程中使用，只有包 `reflect` 可以访问它。 
```go
package main

import (
	"fmt"
	"reflect"
)

type TagType struct { // tags
	field1 bool   "An important answer"
	field2 string "The name of the thing"
	field3 int    "How much there are"
}

func main() {
	tt := TagType{true, "Barak Obama", 1}
	for i := 0; i < 3; i++ {
		refTag(tt, i)
	}
}
func refTag(tt TagType, ix int) {
	ttType := reflect.TypeOf(tt)
	ixField := ttType.Field(ix)
	fmt.Printf("%v\n", ixField.Tag)
}
// An important answer
// The name of the thing
// How much there are
```

## 10.5.匿名字段和嵌入式结构体
有时，包含一个或多个匿名（或嵌入）字段的结构体可能会很有用，即没有明确名称的字段。 只有这种字段的类型是强制性的，并且类型也是它的名字。 这样的匿名字段本身也可以是结构体：`结构体可以包含嵌入式结构体`。

这类似面向对象语言中的继承，下面的一个例子很好的展示着一点：
```go
package main

import "fmt"

type innerS struct {
	in1 int
	in2 int
}
type outerS struct {
	b      int
	c      float32
	int    // anonymous field
	innerS // anonymous field
}

func main() {
	outer := new(outerS)
	outer.b = 6
	outer.c = 7.5
	outer.int = 60
	outer.in1 = 5
	outer.in2 = 10
	fmt.Printf("outer.b is: %d\n", outer.b)
	fmt.Printf("outer.c is: %f\n", outer.c)
	fmt.Printf("outer.int is: %d\n", outer.int)
	fmt.Printf("outer.in1 is: %d\n", outer.in1)
	fmt.Printf("outer.in2 is: %d\n", outer.in2)
	// with a struct-literal:
	outer2 := outerS{6, 7.5, 60, innerS{5, 10}}
	fmt.Println("outer2 is: ", outer2)
}
```
为了存储和访问匿名字段，我们使用了它的数据类型。结果是一个结构体中，每个数据类型的匿名字段只能有一个。

### 10.5.2.嵌入式结构体
一个结构体也是一种类型，他也可以作为匿名字段在结构体中。形如上面的例子，结构体 inners 是结构体 outerS 的匿名字段，可以直接访问 innerS 中的成员变量。这种简单的“继承”机制提供了一种从另一种或多种类型派生出一些或全部实现的方法。

### 10.5.3.命名冲突
有两个名称相同的字段（可能是类型派生的名称）时，规则是什么？

 1. 外部名称隐藏内部名称。 这提供了一种重写字段或方法的方法。
 2. 如果同一个名字在同一级出现两次，如果该名称被程序使用，则是错误的。

下面这个例子很好的解释了上述两点：
```go
type A struct { a int }
type B struct { a, b int }
type C struct { A; B }
type D struct { B; b float32 }
var c C;
var d D;

c.a // error, 不知道是 c.A.a 还是 c.B.a
D.b // ok , 它是 b float32 
```

## 10.6.方法
结构体看起来像一个简单形式的类，所以面向对象程序员可能会问：类的方法在哪里？ Go又有一个名称相同，意义相同的概念：Go方法是一种作用于特定类型变量的函数，称为 `receiver` 。 所以一种方法是一种特殊的函数。

receiver 几乎可以使任何的数据类型而不仅仅是结构体：甚至是一个函数类或者是普通类型的alias。receiver 不可以使接口，因为接口时抽象的定义而类是实现。

(结构体）类型及其方法的组合与OO中的类相当。一个重要的区别是类型的代码和绑定到它的方法没有放在一起; 它们可以存在于不同的源文件中，唯一的要求是它们必须位于同一个包中。

对于类型T的所有方法成为类型T的方法集。

由于方法是一个函数，对于给定的类型，方法没有重载。但是基于 receiver，是可以重载：一个方法名可以实现两个receiver type 在相同的一个包：
```go
func (a *denseMatrix) Add(b Matrix) Matrix
func (a *sparseMatrix) Add(b Matrix) Matrix
```
另外某种类型的别名没有在该类型上定义的方法。

方法的一般格式：
```go
func (recv receiver_type) methodName(parameter_list) (return_value_list) { 
	...
}
```




