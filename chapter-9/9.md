# Chapter 9—Packages
标准库

## 9.1.标准库概述
GO 发行版包含相当多的内置包来实现一般的功能，例如 fmt,os... 这些统称为 `标准库`。可以通过一下进行查阅 [pkg](http://golang.org/pkg/)。

## 9.2.包 `regexp`
测试 pattern 是否发生：
```go
ok, _ := regexp.Match(pat, []byte(searchIn))
ok, _ := regexp.MatchString(pat, searchIn)
```
下面通过一个例子展现 查找和替换：
```go
package main

import (
	"fmt"
	"regexp"
	"strconv"
)

func main() {
	// string to search
	searchIn := "John: 2578.34 William: 4567.23 Steve: 5632.18"
	pat := "[0-9]+.[0-9]+" // pattern to search for in searchIn

	f := func(s string) string {
		v, _ := strconv.ParseFloat(s, 32)
		return strconv.FormatFloat(v*2, 'f', 2, 32)
	}
	if ok, _ := regexp.Match(pat, []byte(searchIn)); ok {
		fmt.Println("Match found!")
	}
	re, _ := regexp.Compile(pat)
	// replace pat with "##.#"
	str := re.ReplaceAllString(searchIn, "##.#")
	fmt.Println(str)
	// using a function :
	str2 := re.ReplaceAllStringFunc(searchIn, f)
	fmt.Println(str2)
}
// Match found!
// John: ##.# William: ##.# Steve: ##.#
// John: 5156.68 William: 9134.46 Steve: 11264.36
```
Compile函数也返回一个错误，我们在这里已经放弃了这个错误，因为我们自己进入了这个模式，并且知道它是一个有效的正则表达式。如果 正则表达式 由用户输入或从数据源取得，那么有必要判断这个错误。我们也可以用 `MustCompile` 来代替这里的 `Compile` 函数，这个函数会在输入一个无效的正则表达式是发生 panic。

# 9.3.包 lock 和 sync
在更复杂的程序中，应用程序的不同部分可以同时或同时执行，这在技术上通常通过在操作系统的不同线程上执行程序的每个部分。当这些不同部分分享和使用相同的变量，最可能发生的问题是：这些共享变量更新的顺序无法预测，因此它们的值也不可预知！（这通常称为竞争条件：线程竞争变量的更新）

经典的方法是同一时间只有一个线程可以改变此共享变量：当一个线程开始执行时，变量被改变的代码（称为关键部分）被锁定，这事没有其他的线程可以开始使用它。仅仅当执行线程已经完成并且解锁发生时，另一个线程才能访问它。

我们前面提到的 map 就不是线程安全的，当出现并发访问是，会导致 map 的数据异常。

在Go中，这种锁是通过 sync 包的 Mutex 变量实现的。 sync 来自 `synchronized` ，这意味着线程被同步以有序地更新变量。sync.Mutex是一个互斥锁，它用于把守代码关键部分的入口，以便一次只有一个线程可以进入关键部分。








